
var HEX = {};


//
// Exceptions

HEX.exception = function(kind,message)
{
  this.kind=kind;
  this.message=message;
}

HEX.exception.prototype = {
  toString : function()
    {
      return this.kind + ": " + this.message;
    }
}

HEX.invalid_argument = function(message)
{
  return new HEX.exception('invalid_argument',message);
}

HEX.out_of_range = function(message)
{
  return new HEX.exception('out_of_range',message);
}


//
// Distance

HEX.M_SQRT3 =1.73205080756887729352744634150587236; // sqrt(3)
HEX.I =1.0;
HEX.J =HEX.M_SQRT3/2.0;
HEX.K =1.0/HEX.M_SQRT3;

//
// Direction

HEX.A=0;
HEX.B=1;
HEX.C=2;
HEX.D=3;
HEX.E=4;
HEX.F=5;
HEX.DIRECTIONS =['A', 'B', 'C', 'D', 'E', 'F'];

HEX.to_direction = function(c)
{
  if(c.length!==1 || c<'A' || c>'F')
      throw HEX.invalid_argument("to_direction: "+c);
  return HEX[c];
}
HEX.to_char = function(d)
{
  if(d<0 || d>HEX.DIRECTIONS.length)
      throw HEX.invalid_argument("to_char: "+d);
  return HEX.DIRECTIONS[d];
}


// Direction arithmetic.

HEX.add = function(d,i)
{
  if(typeof d === 'string')
      d=HEX.to_direction(d);
  d= (d+i) % HEX.DIRECTIONS.length;
  while(d<0)
    d += HEX.DIRECTIONS.length;
  return d;
}
HEX.sub = function(d,i) { return HEX.add(d,-i); }
HEX.inc = function(d)   { return HEX.add(d,1);  }
HEX.dec = function(d)   { return HEX.add(d,-1); }


/** steps is a string of characters A-F, representing a set of Directions.
 *  This function rotates each step by i.
 *
 *  @param steps  String, sequence of direction letters A-Z
 *  @param i      integer, number of directions to rotate (anti-clockwise).
 *  @return       String, sequence of direction letters A-Z
 */
HEX.rotate = function(steps,i)
{
  // Rotate all letters A-F, but leave other characters alone.
  var result ='';
  for(var i=0, len=steps.length; i<len; i++)
  {
    var c =steps.charAt(i);
    if('A'<=c && c<='F')
    {
      d =HEX.to_direction(c);
      c =HEX.to_char(d+i);
    }
    result += c;
  }
  return result;
}

////////////////////////////////////////////////////////////////////////////////
//
//  HEX.Point

/** X-Y coordinate class. */
HEX.Point = function(a,b)
{
  if(typeof a === 'string')
  {
    var piece =a.split(',');
    if(piece.length!==2)
      throw HEX.invalid_argument(a);
    this.i=parseFloat(piece[0]);
    this.j=parseFloat(piece[1]);
  }
  else
  {
    this.x = a? a: 0;
    this.y = b? b: 0;
  }
}

HEX.Point.prototype = {
  offset : function(dx,dy) { return new Point(this.x+dx, this.y+dy); },
  add : function(p) { return new Point(this.x+p.x, this.y+p.y); },
  sub : function(p) { return new Point(this.x-p.x, this.y-p.y); },
  mul : function(v) { return new Point(this.x*v, this.y*v); },
  div : function(v) { return new Point(this.x/v, this.y/v); },
  toString : function() { return ''+this.x+','+this.y; }
};


////////////////////////////////////////////////////////////////////////////////
//
//  HEX.Grid

/** In Javascript the grid is limitless. */
HEX.grid = {
  // factory methods

  hex : function(a,b)
    {
      return new HEX.Hex(a,b);
    },

  /** Parse strings generated by set_str()
   *  @return  sorted Array of unique HEX.Hex objects */
  hexes : function(str)
    {
      var result = [];
      var piece =str.split(' ');
      for(var i=0, len=piece.length; i<len; ++i)
        result.push( new HEX.Hex(piece[i]) );
      HEX.uniq(result);
      return result;
    },

  /** Parse strings generated by Area::str()
   *  @return  object of type HEX.Area */
  area : function(str)
    {
      // Parse string of area fillpaths
      // E.g. 1,2>CDE:ABC
      var result = [];
      var pos =str.search(/[>:]/);
      if(pos<0)
          throw HEX.invalid_argument(str+' [1]');
      var origin =new HEX.Hex( str.substr(0,pos) );
      var start  =origin;
      while(pos>=0)
      {
        var next =HEX.grid._str_find(str,/[>:]/,pos+1);
        var steps =str.substr( pos+1, (next<0)?(str.length):(next-pos-1) );
        if(str.charAt(pos)==='>')
        {
          start=origin.go(steps);
        }
        else // ':'
        {
          var path =new HEX.Path(start,steps);
          result = HEX.set_union(result,path.hexes);
          start=origin;
        }
        pos=next;
      }
      return new HEX.Area(result);
    },

  /** Parse strings generated by Path::str()
   *  @return  object of type HEX.Path */
  path : function(str)
    {
      var colon =str.indexOf(':');
      if(colon<=0 || (colon+1)>=str.length)
          throw HEX.invalid_argument(s);
      var origin =new HEX.Hex( str.substr(0,colon) );
      return new HEX.Path(origin,str.substr(colon+1));
    },

  // String utility
  
  /** Like String.indexOf, except it takes a regular expression. */
  _str_find : function(haystack,needle,start_pos)
    {
      var s =haystack.substr(start_pos);
      var pos =s.search(needle);
      if(pos<0)
        return pos;
      else
        return start_pos+pos;
    }

};


////////////////////////////////////////////////////////////////////////////////
//
//  HEX.Hex

/** Hex location class.
 *
 *  Possible constructors:
 *    new HEX.Hex(i,j)            - i,j are hex's I & J indeces.
 *    new HEX.Hex(hex)            - copy contructor
 *    new HEX.Hex(new Point(x,y)) - x,y are cartesian coordinates
 *    new HEX.Hex(str)            - str is a string like '2_5'
 */
HEX.Hex = function(a,b)
{
  if(typeof a === 'string')
  {
    var piece =a.split('_');
    if(piece.length!==2)
      throw HEX.invalid_argument(a);
    this.i=parseInt(piece[0],10);
    this.j=parseInt(piece[1],10);
  }
  else if(a instanceof HEX.Hex)
  {
    this.i=a.i;
    this.j=a.j;
  }
  else if(a instanceof HEX.Point)
  {
    this._set_from_point(a);
  }
  else
  {
    this.i=a;
    this.j=b;
  }
}

HEX.Hex.prototype = {

  /** Helper: set value from Point. */
  _set_from_point : function(p)
    {
      // (Note I==1.0, so the factor of I has been omitted.)
      var K_2 =HEX.K/2.0;
      // BI is unit vector in direction B
      var BIx = 0.5;
      var BIy = 1.5 * HEX.K;
      // CI is unit vector in direction C
      var CIx = -BIx;
      var CIy =  BIy;

      // Calculate the 'simple' solution.
      var x = p.x;
      var y = p.y - HEX.K;
      this.j = Math.round( y/HEX.J );
      if(this.j % 2)
          x -= 1.0; // odd rows
      else
          x -= 0.5; // even rows
      this.i = Math.round( x );                                     //   x / I
      // Now calculate the x,y offsets (in units of (I,J) )
      var dx = x - this.i;                                          //   i * I
      var dy = y - this.j * HEX.J;
      // Only need more work if |dy| > K/2
      if( dy < -K_2 || K_2 < dy )
      {
        var BId = (BIx * dx) + (BIy * dy);
        var CId = (CIx * dx) + (CIy * dy);

        if(      BId >  0.5 )
                              HEX.go( this, HEX.B );
        else if( BId < -0.5 )
                              HEX.go( this, HEX.E );
        else if( CId >  0.5 )
                              HEX.go( this, HEX.C );
        else if( CId < -0.5 )
                              HEX.go( this, HEX.F );
      }
    },

  /** Get the centre of this hex as a HEX.Point object. */
  centre : function()
    {
      var result = new HEX.Point();
      if(this.j % 2)
          result.x = HEX.I * (1 + this.i); // odd rows
      else 
          result.x = HEX.I/2.0 + HEX.I * this.i; // even rows
      result.y = HEX.K + HEX.J * this.j;
      return result;
    },

  /** Get a NEW HEX.Hex object, translated from this one by steps/distance. */
  go : function(steps, distance)
    {
      var result =new HEX.Hex(this);
      HEX.go(result,steps,distance);
      return result;
    },

  toString : function()
    {
      return ''+this.i+'_'+this.j;
    },

  valueOf : function()
    {
      return 10000*this.i + this.j;
    }

};


////////////////////////////////////////////////////////////////////////////////
//
//  HEX.Path

/** A sequence of adjacent hexes. */
HEX.Path = function(a,b)
{
  if(a instanceof Array)
  {
    this.hexes=a;
    return;
  }
  if(a instanceof HEX.Hex && b instanceof HEX.Hex)
  {
    b=HEX.steps(a,b);
  }
  if(a instanceof HEX.Hex && typeof b === 'string')
  {
    var steps=b;
    this.hexes=[a];
    var cur =0;
    while(cur<steps.length && steps.charAt(cur)!=='?')
    {
      // Find direction
      var dir =HEX.to_direction( steps.charAt(cur) );
      ++cur;
      var repeat =(cur<steps.length && steps.charAt(cur)==='*');
      do{
          var next =this.hexes[this.hexes.length-1].go( dir );
          if(next)
              this.hexes.push( next );
          else if(steps.charAt(steps.length-1)==='?' || repeat)
              return; // bail out instead of throwing
          else
              throw HEX.out_of_range('path:'+steps);
      } while(repeat);
    }
  }
  else
    throw HEX.invalid_argument('HEX.Path()');
}

HEX.Path.prototype = {

  to_area : function() { return new HEX.Area(this.hexes); },
  length  : function() { return this.hexes.length; }, ///< in units of I

  steps : function()
    {
      var result ='';
      var curr =0;
      for(var h=0, len=this.hexes.length; h<len; ++h)
      {
        if(curr)
            result += HEX.steps( curr, this.hexes[h] );
        curr = this.hexes[h];
      }
      return result;
    },
    
  toString : function()
    {
      var result =this.hexes[0].toString();
      result+=':'+this.steps();
      return result;
    }

};


////////////////////////////////////////////////////////////////////////////////
//
//  HEX.Area

/** A connected set of hexes. */
HEX.Area = function(hexset)
{
  if(!(hexset instanceof Array))
    throw HEX.invalid_argument();
  this.hexes = hexset;
}

HEX.Area.prototype = {

  size     : function()  { return this.hexes.length; },
  contains : function(h) { return HEX.set_contains(this.hexes,h); },

  // boundary()
  // enclosed_areas()
  // skeleton(include_boundary)

  /** A list of one or more paths that include every hex in the area once. */
  fillpaths : function(origin)
    {
      var result = []; // list of Paths
      // Try to calculate a path that fills area.
      var queue =this.hexes.slice(0); // copy
      var seen = [];
      var path = [];
      var hex = origin? origin: queue[0];
      var dir = HEX.F;
      while(queue.length)
      {
        path.push( hex );
        HEX.set_erase(queue,hex);
        HEX.set_insert(seen,hex);
        var d=HEX.add(dir,1);
        while(true)
        {
          if(d===dir)
          {
            result.push( new HEX.Path(path) );
            path = [];
            hex = queue[0];
            break;
          }
          var hd =hex.go(d);
          if(HEX.set_contains(queue,hd) && !HEX.set_contains(seen,hd))
          {
            hex = hd;
            dir = HEX.add(d,3);
            break;
          }
          d=HEX.inc(d);
        }
      }
      return result;
    },

  toString : function(origin)
    {
      origin = origin? origin: this.hexes[0];
      var result = '';
      var paths  =this.fillpaths(origin);
      result += origin.toString();
      for(var p =0, len=paths.length; p<len; ++p)
      {
        if(paths[p].hexes[0].valueOf() !== origin.valueOf())
            result += ">" + HEX.steps(origin,paths[p].hexes[0]);
        result += ":" + paths[p].steps();
      }
      return result;
    },

  go : function(steps,distance)
    {
      var result = [];
      for(var h=0, len=this.hexes.length; h<len; ++i)
        result.push( this.hexes[h].go(steps,distance) );
      return new HEX.Area(result);
    }
};


////////////////////////////////////////////////////////////////////////////////
//
//  Algorithms


/** Translates hex along steps. (If steps is just one char, then it
 *  goes for distance hexes.)
 *
 *  @param hex       in/out object of type HEX.Hex
 *  @param steps     String, sequence of direction letters A-F
 *                   OR integer value HEX.A..HEX.F
 *  @param distance  optional integer in hexes (if steps is single-valued)
 */
HEX.go = function(hex, steps, distance)
{
  if(typeof steps === 'number')
      steps=HEX.to_char(steps);
  if(steps.length>1 || !distance)
      distance = 1;

  for(var x=0; x<(distance?distance:1); x++)
  {
    for(var s=0, len=steps.length; s<len; ++s)
    {
      var c =steps.charAt(s);
      if('A'>c || c>'F')
          return;
      var direction=HEX.to_direction(c);
      if(hex.j%2)
          switch(direction) // odd
          {
            case HEX.A: ++hex.i;          break;
            case HEX.B: ++hex.i; ++hex.j; break;
            case HEX.C:          ++hex.j; break;
            case HEX.D: --hex.i;          break;
            case HEX.E:          --hex.j; break;
            case HEX.F: ++hex.i; --hex.j; break;
            default: throw HEX.invalid_argument('go: '+direction);
          }
      else
          switch(direction) // even
          {
            case HEX.A: ++hex.i;          break;
            case HEX.B:          ++hex.j; break;
            case HEX.C: --hex.i; ++hex.j; break;
            case HEX.D: --hex.i;          break;
            case HEX.E: --hex.i; --hex.j; break;
            case HEX.F:          --hex.j; break;
            default: throw HEX.invalid_argument('go: '+direction);
          }
    }
  }
}


/** Calculates a minimum-length path between two hexes.
 *  The result is one of many possible solutions.
 *
 *  @param from  object of type HEX.Hex
 *  @param to    object of type HEX.Hex
 *  @return      String, sequence of direction letters A-F
 */
HEX.steps = function(from,to)
{
  var result ='';
  var hex =new HEX.Hex(from);
  var direction;
  while(true)
  {
    if( hex.j < to.j )                                          // go up
    {
        if(      hex.i < to.i )              direction = HEX.B;
        else if( hex.i > to.i || hex.j%2 )   direction = HEX.C;
        else                                 direction = HEX.B;
    }
    else if( hex.j > to.j )                                     // go down
    {
        if(      hex.i < to.i )              direction = HEX.F;
        else if( hex.i > to.i || hex.j%2 )   direction = HEX.E;
        else                                 direction = HEX.F;
    }
    else // hex.j == to.j                                       // go across
    {
        if(      hex.i < to.i )              direction = HEX.A;
        else if( hex.i > to.i )              direction = HEX.D;
        else                                 break;             //  Done!
    }
    result += HEX.to_char(direction);
    HEX.go(hex,direction);
  }
  return result;
}


/** The length of the shortest path between two hexes.
 *
 *  @param from  object of type HEX.Hex
 *  @param to    object of type HEX.Hex
 *  @return      integer distance (in hexes)
 */
HEX.distance = function(from,to)
{
  return HEX.steps(from,to).length;
}


/** Calculates the set of hexes that are range r from hex h.
 *  The result may NOT be a valid Area, since it may be cut into several
 *  pieces by the edge of the grid.
 *
 *  @param h         object of type HEX.Hex
 *  @param distance  integer range (in hexes)
 *  @return          Sorted Array of unique HEX.Hex objects
 */
HEX.range = function(h,distance)
{
  var result = [];
  if(distance<1)
  {
    result.push(h);
  }
  else
  {
    var hex = new HEX.Hex(h);

    HEX.go(hex,HEX.A,distance); // in/out: hex
    result.push( new HEX.Hex(hex) );
  
    for(var d=0; d<HEX.DIRECTIONS.length; ++d)
    {
      var direction =HEX.add(HEX.C,d);
      for(var count=0; count<distance; ++count)
      {
        HEX.go(hex,direction); // in/out: hex
        result.push( new HEX.Hex(hex) );
      }
    }
  }
  result.sort();
  return result;
}


/** Ensures that hex_array is a sorted set of unique Hexes.
 *
 *  @param hex_array  in/out Array of HEX.Hex objects
 *  @return           !!NONE!! - hex_array is modified directly.
 */
HEX.uniq = function(hex_array)
{
  hex_array.sort();
  var new_length =hex_array.length;
  var curr =-1;
  for(var i=0, len=hex_array.length; i<len; ++i)
  {
    if(curr.valueOf() === hex_array[i].valueOf())
    {
      delete hex_array[i];
      --new_length;
    }
    else
    {
      curr = hex_array[i];
    }
  }
  if(new_length!==len)
  {
    hex_array.sort(); // pushes all empty elements to the end.
    hex_array.length = new_length;
  }
}


HEX.set_find = function(hexset,hex)
{
  // binary chop.
  var lower=0, upper=hexset.length-1;
  while(lower <= upper)
  {
    var pos=Math.floor((lower+upper)/2);
    if(hexset[pos] > hex)
      upper = pos - 1;
    else if(hexset[pos] < hex)
      lower = pos + 1;
    else
      return pos;
  }
  return -1;
}


HEX.set_contains = function(hexset,hex)
{
  return HEX.set_find(hexset,hex) >= 0;
}


/** Inserts Hex h into hex_array (and incidentally, turn it into a
 *  sorted unique set).
 *
 *  @param hex_array  in/out Array of HEX.Hex objects -> set
 *  @param h          HEX.Hex object
 *  @return           !!NONE!! - hex_array is modified directly.
 */
HEX.set_insert = function(hex_array,h)
{
  hex_array.push(h);
  HEX.uniq(hex_array);
}


/** Remove Hex h from hexset.
 *
 *  @param hexset  in/out Sorted Array of unique HEX.Hex objects
 *  @param h       HEX.Hex object
 *  @return        TRUE iff hexset contained h
 */
HEX.set_erase = function(hexset,h)
{
  var pos = HEX.set_find(hexset,h);
  if(pos>=0)
  {
    delete hexset[pos];
    hexset.sort();
    hexset.pop();
    return true;
  }
  return false;
}


/** The set difference between a and b.
 *
 *  @params  Sorted array of unique HEX.Hex objects
 *  @return  Sorted array of unique HEX.Hex objects
 */
HEX.set_difference = function(a,b)
{
  var result = [];
  for(var i=0, len=a.length; i<len; ++i)
    if(!HEX.set_contains(b,a[i]))
      result.push( new HEX.Hex(a[i]) );
  return result;
}


/** The set intersection between a and b.
 *
 *  @params  Sorted array of unique HEX.Hex objects
 *  @return  Sorted array of unique HEX.Hex objects
 */
HEX.set_intersection = function(a,b)
{
  var result = [];
  for(var i=0, len=a.length; i<len; ++i)
    if(HEX.set_contains(b,a[i]))
      result.push( new HEX.Hex(a[i]) );
  return result;
}


/** The set set_union between a and b.
 *
 *  @params  Array of HEX.Hex objects
 *  @return  Array of HEX.Hex objects
 */
HEX.set_union = function(a,b)
{
  var result =a.concat(b);
  HEX.uniq( result );
  return result;
}


/** Generates a string representation of hex-set a.
 *
 *  @param a  Array of HEX.Hex objects
 *  @return   string representation
 */
HEX.set_str = function(a)
{
  var result ='';
  for(var i=0, len=a.length; i<len; ++i)
    result += a[i].toString() + ' ';
  return result;
}


/** Max. area that contains hexes in a, but does not intersect beyond.
 *
 *  @param beyond  Array of HEX.Hex objects, that delimit the area to be filled.
 *  @param a       Array of HEX.Hex objects, that delimit the area to be filled.
 *                 OR a single HEX.Hex object.
 *  @return        Array of HEX.Hex objects
 */
HEX.fill = function(beyond, a)
{
  if(a instanceof HEX.Hex)
    a = [a];

  var queue  = a.slice(0); // copy a
  var result = a.slice(0); // copy a
  while(queue.length)
  {
    var h = queue.shift();
    for(var d=0; d<HEX.DIRECTIONS.length; ++d)
    {
      var hd =h.go( HEX.add(HEX.A+d) );
      if(!HEX.set_contains(beyond,hd) && !HEX.set_contains(result,hd))
      {
        HEX.set_insert(queue,hd);
        HEX.set_insert(result,hd);
      }
    }
  }
  return result;
}


/** Helper: Find the connected set (Area) that contains the first hex in s. */
HEX._extract_connected_set = function(s)
{
  var result = [];
  var queue  = []; // Hexes in result that have not yet been checked.
  var h = s[0]; // Just pick a random hex in s.
  while(true)
  {
    HEX.set_insert(result,h);
    HEX.set_erase(s,h);
    if(s.length===0)
        break; // optimisation - not strictly necessary.
    var range1 =HEX.set_intersection( s, HEX.range(h,1) );
    queue = HEX.set_union( queue, range1 );
    if(queue.length===0)
        break;
    h = queue.shift();
  }
  return result;
}


/** Find all of the Areas (connected sets) in s.
 *
 *  @param s  Sorted set of unique HEX.Hex objects.
 *  @return   Array of sorted sets of unique HEX.Hex objects.
 */
HEX.areas = function(s)
{
  var unallocated = s.slice(0); // copy of s
  var result = [];
  while(unallocated.length>0)
  {
    result.push( HEX._extract_connected_set(unallocated) );
  }
  return result;
}


/** TRUE iff s is connected.
 *
 *  @param s  Sorted set of unique HEX.Hex objects.
 *  @return   bool
 */
HEX.is_connected = function(s)
{
  var unallocated = s.slice(0);
  HEX._extract_connected_set( unallocated );
  return( unallocated.length===0 );
}
